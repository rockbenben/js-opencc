/**
 * OpenCC JS - Converter Builder
 * High-level API for creating converters
 */

// Imports removed

import { ConverterFactory, DictGroup, DictLike } from "./core.js";
import { variants2standard, standard2variants, LocaleCode } from "./presets.js";

// Dict modules will be generated by sync-opencc script
// Import them dynamically or statically after running sync

/**
 * Converter options
 */
export interface ConverterOptions {
  /** Source locale code */
  from: LocaleCode;
  /** Target locale code */
  to: LocaleCode;
  /** Whether to load custom phrase dictionary (default: true for twp) */
  loadCustomPhrases?: boolean;
  /** Whether to apply character fixes (default: true) */
  applyCharFixes?: boolean;
}

/**
 * Locale preset data containing dictionary groups
 */
export interface LocalePreset {
  from: Record<string, DictGroup>;
  to: Record<string, DictGroup>;
}

/**
 * Create a Converter factory with locale preset
 * @param localePreset - Preset containing dictionary groups for each locale
 * @returns Converter factory function
 */
export function ConverterBuilder(localePreset: LocalePreset) {
  return function Converter(options: ConverterOptions): (input: string) => string {
    const dictGroups: DictGroup[] = [];

    // Add 'from' dictionaries (variant -> standard)
    if (options.from !== "t" && localePreset.from[options.from]) {
      dictGroups.push(localePreset.from[options.from]);
    }

    // Add 'to' dictionaries (standard -> variant)
    if (options.to !== "t" && localePreset.to[options.to]) {
      dictGroups.push(localePreset.to[options.to]);
    }

    return ConverterFactory(...dictGroups);
  };
}

/**
 * Get dictionary file list for a conversion direction
 */
export function getDictFiles(from: LocaleCode, to: LocaleCode): string[] {
  const files: string[] = [];

  if (from !== "t") {
    files.push(...(variants2standard[from] || []));
  }

  if (to !== "t") {
    files.push(...(standard2variants[to] || []));
  }

  return files;
}

/**
 * Load dictionaries and create a converter
 * This is the recommended way to create converters in Node.js
 *
 * @param options - Converter options
 * @param customDict - Additional custom dictionary entries
 */
export async function createConverter(options: ConverterOptions, customDict?: DictLike): Promise<(input: string) => string> {
  const dictFiles = getDictFiles(options.from, options.to);
  const dictGroups: DictGroup[] = [];

  // Import all dictionaries
  const dictModules = await import("./dict/index.js");

  // Helper to load dictionary from modules
  const loadDictFromModule = (name: string): string[][] | null => {
    const dictData = (dictModules as Record<string, string>)[name];
    if (!dictData) return null;
    return dictData.split("|").map((entry) => {
      const parts = entry.split(" ");
      const k = parts[0];
      const v = parts.slice(1).join(" ");
      return [k, v || k]; // For single char which might be optimized to just "A" if A->A
    });
  };

  // Load each required dictionary
  for (const fileName of dictFiles) {
    const dict = loadDictFromModule(fileName);
    if (dict) {
      dictGroups.push([dict]);
    } else {
      console.warn(`Dictionary ${fileName} not found. Run 'npm run sync:opencc' first.`);
    }
  }

  // Auto-load custom phrase dictionary for twp conversion
  const loadPhrases = options.loadCustomPhrases ?? (options.to === "twp" || options.from === "twp");
  if (loadPhrases) {
    const phrases = loadDictFromModule("CNTWPhrases");
    if (phrases) {
      // For cn → twp: use as-is (大陸 → 台灣)
      // For twp → cn: reverse the mapping (台灣 → 大陸)
      if (options.from === "twp" && options.to === "cn") {
        const reversed = phrases.map(([cn, tw]) => [tw, cn]);
        dictGroups.unshift([reversed]);
      } else {
        dictGroups.unshift([phrases]);
      }
    }
  }

  // Apply character fixes (always enabled by default)
  const applyFixes = options.applyCharFixes ?? true;
  if (applyFixes) {
    const fixes = loadDictFromModule("CharFixes");
    if (fixes) {
      dictGroups.unshift([fixes]);
    }
  }

  // Add user-provided custom dictionary
  if (customDict) {
    dictGroups.unshift([customDict]);
  }

  return ConverterFactory(...dictGroups);
}

// Re-export types
export type { LocaleCode } from "./presets.js";
export type { DictLike, DictGroup } from "./core.js";
